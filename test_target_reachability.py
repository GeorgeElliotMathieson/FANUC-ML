#!/usr/bin/env python3
# Script to test the reachability of targets generated by the RobotPositioningRevampedEnv

from src.envs.robot_sim import RobotPositioningRevampedEnv
import numpy as np
import time

def test_target_reachability(num_tests=50, visualize=False):
    """
    Test if the targets generated by the environment are reachable.
    
    Args:
        num_tests: Number of targets to test
        visualize: Whether to enable visualization
    """
    print(f"Testing reachability of {num_tests} targets...")
    
    # Initialize environment with visualization enabled if requested
    env = RobotPositioningRevampedEnv(
        gui=visualize,
        verbose=True,
        viz_speed=0.02 if visualize else 0.0
    )
    
    # Test with different curriculum levels
    reachable_targets = 0
    target_distances = []
    home_pos = env.home_position
    
    # Check each curriculum level
    for level in range(env.curriculum_max_levels):
        print(f"\nTesting curriculum level {level}/{env.curriculum_max_levels-1}")
        env.curriculum_level = level
        
        level_targets = num_tests // env.curriculum_max_levels
        level_reachable = 0
        level_distances = []
        
        for i in range(level_targets):
            # Reset environment to get a new target
            obs, info = env.reset()
            
            # Get target position
            target = env.target_position
            
            # Check if the target is reachable
            is_reachable = env._is_position_reachable(target)
            
            # Calculate distance from home
            distance = np.linalg.norm(target - home_pos)
            target_distances.append(distance)
            level_distances.append(distance)
            
            if is_reachable:
                reachable_targets += 1
                level_reachable += 1
            
            print(f"  Target {i+1}: {'Reachable' if is_reachable else 'NOT REACHABLE'}, " 
                  f"Distance: {distance:.3f}m")
            
            # Small delay for visualization if enabled
            if visualize:
                time.sleep(0.5)
        
        # Report level statistics
        level_reachability = level_reachable / level_targets * 100
        avg_distance = np.mean(level_distances) if level_distances else 0
        min_distance = np.min(level_distances) if level_distances else 0
        max_distance = np.max(level_distances) if level_distances else 0
        
        print(f"  Level {level} results:")
        print(f"    Reachable targets: {level_reachable}/{level_targets} ({level_reachability:.1f}%)")
        print(f"    Distance from home: min={min_distance:.3f}m, avg={avg_distance:.3f}m, max={max_distance:.3f}m")
    
    # Report overall statistics
    reachability = reachable_targets / num_tests * 100
    avg_distance = np.mean(target_distances)
    min_distance = np.min(target_distances)
    max_distance = np.max(target_distances)
    
    print("\nOverall results:")
    print(f"  Reachable targets: {reachable_targets}/{num_tests} ({reachability:.1f}%)")
    print(f"  Distance from home: min={min_distance:.3f}m, avg={avg_distance:.3f}m, max={max_distance:.3f}m")
    
    # Close environment
    env.close()
    
    return reachability

if __name__ == "__main__":
    # Run the test with visualization
    reachability = test_target_reachability(num_tests=25, visualize=True)
    
    # Report final result
    if reachability == 100.0:
        print("\nSUCCESS: All targets are reachable!")
    else:
        print(f"\nWARNING: Only {reachability:.1f}% of targets are reachable!") 